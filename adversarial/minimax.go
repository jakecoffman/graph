package adversarial

import (
	"math"
	"sort"
)

type GameState interface {
	IsGameOver() bool
	Score() int
	NextStates() []GameState
}

// Minimax implements depth-limited minimax with alpha-beta pruning. It returns the index of the
// optimal state from the array generated by NextStates. This assumes the player who needs
// to play next will be the maximizing player.
func Minimax(state GameState) int {
	children := state.NextStates()
	var results []result
	for i := range children {
		child := children[i]
		_, value := minimax(child, 1, math.MinInt64, math.MaxInt64, false)
		results = append(results, result{
			move:  i,
			value: value,
		})
	}
	sort.Slice(results, func(i, j int) bool {
		return results[i].value > results[j].value
	})
	// uncomment for debugging, this returns the value of the moves
	//fmt.Println("RESULTS", results)
	return results[0].move
}

type result struct {
	move, value int
}

// depth is the maximum depth to examine
// alpha represents the minimum score that the maximizing player is assured of
// beta represents the maximum score that the minimizing player is assured of
// Initially, alpha should be set to negative infinity and beta positive infinity.
func minimax(state GameState, depth, alpha, beta int, maximizingPlayer bool) (int, int) {
	if state.IsGameOver() {
		return -1, state.Score()
	}
	if maximizingPlayer {
		value := math.MinInt64
		move := -1
		children := state.NextStates()
		for i := range children {
			child := children[i]
			_, newValue := minimax(child, depth+1, alpha, beta, false)
			value = max(value, newValue)
			if value == newValue {
				move = i
			}
			//if value >= beta {
			//	break // beta pruning
			//}
			alpha = max(alpha, value)
		}
		return move, value
	} else {
		bestScore := math.MaxInt64
		move := -1
		children := state.NextStates()
		for i := range children {
			child := children[i]
			_, score := minimax(child, depth+1, alpha, beta, true)
			bestScore = min(bestScore, score)
			if bestScore == score {
				move = i
			}
			//if bestScore <= alpha {
			//	break // alpha pruning
			//}
			beta = min(beta, bestScore)
		}
		return move, bestScore
	}
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}
