package adversarial

import (
	"math"
	"sort"
)

type GameState interface {
	IsGameOver() bool
	Score() int
	NextStates() []GameState
}

// Negamax implements depth-limited negamax with alpha-beta pruning. It returns the index of the
// optimal state from the array generated by NextStates. This assumes the player who needs
// to play next will be the maximizing player.
func Negamax(state GameState, maxDepth int) int {
	var results []result
	alpha, beta := math.MinInt64+1, math.MaxInt64

	children := state.NextStates()
	for i := range children {
		child := children[i]
		value := -negamax(child, maxDepth-1, -beta, -alpha, -1)
		results = append(results, result{
			move:  i,
			value: value,
		})
	}
	sort.Slice(results, func(i, j int) bool {
		return results[i].value > results[j].value
	})
	// uncomment for debugging, this returns the value of the moves
	//fmt.Println("RESULTS", results)
	return results[0].move
}

type result struct {
	move, value int
}

// depth is the maximum depth to examine
// alpha represents the minimum score that the maximizing player is assured of
// beta represents the maximum score that the minimizing player is assured of
// Initially, alpha should be set to negative infinity and beta positive infinity.
func negamax(state GameState, depth, alpha, beta int, color int) int {
	if depth == 0 || state.IsGameOver() {
		return color * state.Score()
	}
	value := math.MinInt64
	children := state.NextStates()
	for i := range children {
		child := children[i]
		value = max(value, -negamax(child, depth-1, -beta, -alpha, -color))
		alpha = max(alpha, value)
		if alpha >= beta {
			break // cut-off
		}
	}
	return value
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}
