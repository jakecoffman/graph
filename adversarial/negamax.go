package adversarial

import (
	"math"
	"sort"
)

type GameState interface {
	// IsGameOver returns true when the game is over, win lose or draw.
	IsGameOver() bool
	// Score returns a positive score if the player won,
	// negative if they lost, 0 otherwise.
	Score() int
	// NextStates returns a list of possible next game states.
	NextStates(color int) []GameState
	// Hash returns a hashable value for the game state so that
	// repeated states can be found by a map lookup. Google "Zobrist Hash".
	Hash(color int) uint64
}

// Negamax implements depth-limited negamax with alpha-beta pruning and transposition tables.
// It returns the index of the optimal state from the array generated by NextStates.
// This assumes the player who needs to play next will be the maximizing player.
func Negamax(state GameState, maxDepth, color int) int {
	var results []result
	alpha, beta := math.MinInt64+1, math.MaxInt64

	children := state.NextStates(color)
	for i := range children {
		child := children[i]
		value := -negamax(child, maxDepth-1, -beta, -alpha, -color)
		results = append(results, result{
			move:  i,
			value: value,
		})
	}
	sort.Slice(results, func(i, j int) bool {
		return results[i].value > results[j].value
	})
	// uncomment for debugging, this returns the value of the moves
	//fmt.Println("RESULTS", results)
	return results[0].move
}

type result struct {
	move, value int
}

var transpositionTable = map[uint64]entry{}

type flag int

const (
	flagExact = flag(iota)
	flagLowerBound
	flagUpperBound
)

type entry struct {
	flag
	depth int
	value int
}

// depth is the maximum depth to examine
// alpha represents the minimum score that the maximizing player is assured of
// beta represents the maximum score that the minimizing player is assured of
// Initially, alpha should be set to negative infinity and beta positive infinity.
func negamax(state GameState, depth, alpha, beta int, color int) int {
	alphaOrig := alpha
	hash := state.Hash(color)
	ttEntry, ok := transpositionTable[hash]
	if ok && ttEntry.depth >= depth {
		if ttEntry.flag == flagExact {
			return ttEntry.value
		}
		if ttEntry.flag == flagLowerBound {
			alpha = max(alpha, ttEntry.value)
		} else if ttEntry.flag == flagUpperBound {
			beta = min(beta, ttEntry.value)
		}
		if alpha >= beta {
			return ttEntry.value
		}
	}

	if depth == 0 || state.IsGameOver() {
		return color * state.Score()
	}
	value := math.MinInt64
	children := state.NextStates(color)
	for i := range children {
		child := children[i]
		value = max(value, -negamax(child, depth-1, -beta, -alpha, -color))
		alpha = max(alpha, value)
		if alpha >= beta {
			break // cut-off
		}
	}

	ttEntry = entry{
		value: value,
		depth: depth,
	}
	if value <= alphaOrig {
		ttEntry.flag = flagUpperBound
	} else if value >= beta {
		ttEntry.flag = flagLowerBound
	} else {
		ttEntry.flag = flagExact
	}
	transpositionTable[hash] = ttEntry

	return value
}

func max(a, b int) int {
	if a < b {
		return b
	}
	return a
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
